
<!DOCTYPE html>

<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Robot Arena ‚Äî –°–∏–º—É–ª—è—Ü–∏—è (–ª–æ–≥ —Å–ø—Ä–∞–≤–∞, –ø—Ä–∞–≤–∏–ª–∞ –≤–Ω–∏–∑—É)</title>
<script src="https://cdn.tailwindcss.com">
  /* TURN_ENERGY_PREINIT */
  var TURN_ENERGY = 20;
  var turnFresh = { 1: true, 2: true };

  window.addEventListener('load',()=>{ try{ updateEnergyUI(); }catch(e){} });
</script>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;600;700&display=swap');
    body { font-family: 'Inter', sans-serif; }
    .font-orbitron { font-family: 'Orbitron', sans-serif; }
    .gradient-bg { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    .gradient-text { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .glass-effect { background: rgba(255,255,255,.05); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,.1); }
    .grid-pattern { background-image: linear-gradient(rgba(102,126,234,.1) 1px, transparent 1px), linear-gradient(90deg, rgba(102,126,234,.1) 1px, transparent 1px); background-size: 50px 50px; }
    .pulse-glow { animation: pulse-glow 2s ease-in-out infinite; }
    @keyframes pulse-glow { 0%,100%{ box-shadow: 0 0 20px rgba(102,126,234,.5);} 50%{ box-shadow: 0 0 40px rgba(102,126,234,.8);} }
    .pill{ animation: pill-fade 1.8s ease-out forwards; }
    @keyframes pill-fade{ 0%{ opacity:0; transform: translate(-50%,-6px) scale(.95); } 10%{ opacity:1; transform: translate(-50%,-8px) scale(1);} 85%{ opacity:1; transform: translate(-50%,-10px) scale(1);} 100%{ opacity:0; transform: translate(-50%,-12px) scale(.98);} }
  
    .hit-anim { animation: hit-flash 1.5s ease-in-out; }
    @keyframes hit-flash {
      0%   { filter: drop-shadow(0 0 0 rgba(239,68,68,0));   }
      50%  { filter: drop-shadow(0 0 18px rgba(239,68,68,0.95)); }
      100% { filter: drop-shadow(0 0 0 rgba(239,68,68,0));   }
    }
    
    /* stronger on-hit pulse + slight shake */
    .hit-pulse { animation: hitPulse 1.5s ease-in-out; }
    @keyframes hitPulse {
      0%   { box-shadow: 0 0 0 rgba(239,68,68,0); }
      35%  { box-shadow: 0 0 24px rgba(239,68,68,0.9); }
      70%  { box-shadow: 0 0 12px rgba(239,68,68,0.4); }
      100% { box-shadow: 0 0 0 rgba(239,68,68,0); }
    }
    .shake { animation: shake 0.35s ease-in-out 0s 3; }
    @keyframes shake {
      0%,100% { transform: translate(0,0); }
      20% { transform: translate(-1.5px, 0); }
      40% { transform: translate(1.5px, 0); }
      60% { transform: translate(-1.5px, 0); }
      80% { transform: translate(1.5px, 0); }
    }
    
    .fade-in { animation: fadeIn 0.2s ease-out forwards; }
    .fade-out { animation: fadeOut 0.2s ease-in forwards; }
    @keyframes fadeIn { from { opacity: 0; transform: translate(-50%,-55%); } to { opacity: 1; transform: translate(-50%,-50%);} }
    @keyframes fadeOut { from { opacity: 1; transform: translate(-50%,-50%);} to { opacity: 0; transform: translate(-50%,-45%);} }
    
    /* Shooter FX: saturate the robot and show a pulsating frame */
    .shooter-saturate { filter: saturate(2) brightness(1.2) contrast(1.05); }
    .shooter-ring-blue { border: 4px solid rgba(59,130,246,0.98); box-shadow: 0 0 24px rgba(59,130,246,0.95), 0 0 40px rgba(59,130,246,0.55); animation: ringPulseBlue 0.8s ease-in-out infinite; border-radius: 0.5rem; }
    .shooter-ring-red  { border: 4px solid rgba(239,68,68,0.98); box-shadow: 0 0 24px rgba(239,68,68,0.95), 0 0 40px rgba(239,68,68,0.55); animation: ringPulseRed  0.8s ease-in-out infinite; border-radius: 0.5rem; }
    @keyframes ringPulseBlue {
  0%   { transform: scale(1);    box-shadow: 0 0 18px rgba(59,130,246,.85), 0 0 26px rgba(59,130,246,.35); }
  }
      50%  { transform: scale(1.08);  box-shadow: 0 0 34px rgba(59,130,246,1),   0 0 60px rgba(59,130,246,0.6);  }
      100% { transform: scale(1);     box-shadow: 0 0 18px rgba(59,130,246,0.85), 0 0 26px rgba(59,130,246,0.35); }
    }
      50%  { transform: scale(1.05);  box-shadow: 0 0 26px rgba(59,130,246,1);    }
      100% { transform: scale(1);     box-shadow: 0 0 12px rgba(59,130,246,0.75); }
    }
    @keyframes ringPulseRed {
  0%   { transform: scale(1);    box-shadow: 0 0 18px rgba(239,68,68,.85), 0 0 26px rgba(239,68,68,.35); }
  }
      50%  { transform: scale(1.08);  box-shadow: 0 0 34px rgba(239,68,68,1),   0 0 60px rgba(239,68,68,0.6);  }
      100% { transform: scale(1);     box-shadow: 0 0 18px rgba(239,68,68,0.85), 0 0 26px rgba(239,68,68,0.35); }
    }
      50%  { transform: scale(1.05);  box-shadow: 0 0 26px rgba(239,68,68,1);    }
      100% { transform: scale(1);     box-shadow: 0 0 12px rgba(239,68,68,0.75); }
    }
    
/* Stable grid cell sizing */

#game-demo > div.cell {
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: relative;
  box-sizing: border-box;
}
</style>
</head>
<body class="bg-gray-900 text-white">
<!-- Hero (–æ—Å—Ç–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Ä–∞–∑–¥–µ–ª–∞) -->
<section class="pt-10 pb-6 grid-pattern relative overflow-hidden">
<div class="absolute inset-0 bg-gradient-to-b from-transparent to-gray-900 pointer-events-none"></div>
<div class="container mx-auto px-6 relative z-10">
<h1 class="text-4xl md:text-5xl font-orbitron font-extrabold text-center">–°–∏–º—É–ª—è—Ü–∏—è –±–æ—è</h1>
</div>
</section>
<!-- Arena + Log side-by-side -->
<section class="py-6 bg-gray-800">
<div class="container mx-auto px-6">
<div class="grid md:grid-cols-3 gap-6 items-start">
<!-- Arena (2/3) -->
<div class="md:col-span-1 md:sticky md:top-8 self-start">
<div class="aspect-square w-full mx-auto bg-gray-900 rounded-2xl border-2 border-purple-500 p-6 shadow-2xl relative">
<div class="hidden absolute z-20 top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[80%] h-[30%] rounded-2xl glass-effect border border-white/20 shadow-2xl flex items-center justify-center text-center" id="win-overlay">
<div class="text-2xl md:text-3xl font-orbitron font-extrabold" id="win-text"></div>
<div class="mt-2 text-sm md:text-base text-gray-300" id="win-meta"></div>
</div>

<div id="energy-panel" class="flex gap-4 items-center mb-2 text-sm">
  <div class="px-2 py-1 rounded bg-gray-800">R1 ‚ö° <span id="energy-r1">-</span> | HP <span id="hp-r1">-</span> | üõ° <span id="shield-r1">0</span></div>
  <div class="px-2 py-1 rounded bg-gray-800">R2 ‚ö° <span id="energy-r2">-</span> | HP <span id="hp-r2">-</span> | üõ° <span id="shield-r2">0</span></div>
  </div>
<div class="grid grid-cols-10 gap-1 h-full" id="game-demo"></div>
</div>
<!-- Stats under arena -->
<div class="mt-4 glass-effect rounded-lg p-4">
<div class="text-center text-sm text-gray-400 mb-2">–°–∏–º—É–ª—è—Ü–∏—è –±–æ—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏</div>
<div class="flex justify-around text-xs">
<div class="flex items-center gap-2"><span class="inline-block w-3 h-3 bg-blue-500 rounded"></span><span class="text-blue-400">–†–æ–±–æ—Ç-1: <span id="robot1-hp">100</span> HP</span></div>
<div class="flex items-center gap-2"><span class="inline-block w-3 h-3 bg-red-500 rounded"></span><span class="text-red-400">–†–æ–±–æ—Ç-2: <span id="robot2-hp">100</span> HP</span></div>
</div>
<div class="mt-2 text-xs text-purple-400 text-center">–•–æ–¥: <span id="turn-number">1</span></div>
<div class="mt-4">
<label class="block text-xs text-gray-400 mb-1">–°–∫–æ—Ä–æ—Å—Ç—å —Å–∏–º—É–ª—è—Ü–∏–∏: <span id="speed-label">1.0 —Å/—Ö–æ–¥</span></label>
<input class="w-full accent-purple-500" id="speed-slider" max="3" min="1" step="0.25" type="range" value="1"/>
</div>
<div class="mt-3 text-xs flex items-center justify-center gap-3">
<label class="text-gray-400" for="grid-size">–†–∞–∑–º–µ—Ä —Å–µ—Ç–∫–∏:</label>
<input class="w-40" id="grid-size" max="20" min="6" type="range" value="10"/>
<span class="text-gray-300" id="grid-size-val">10√ó10</span>
</div>
<div class="mt-3 text-xs flex items-center justify-center gap-3">
<label class="inline-flex items-center gap-2">
<input class="accent-purple-500" id="fog-toggle" type="checkbox"/>
<span class="text-gray-400">Fog of War</span>
</label>
<span class="text-gray-500">—Ä–∞–¥–∏—É—Å: 3</span>
</div>
</div>
</div>
<!-- Action Log (1/3) -->
<aside class="md:col-span-2 md:sticky md:top-6 self-start w-full">
<div class="glass-effect rounded-xl p-4 border border-white/10">
<div class="text-sm font-semibold text-gray-300 mb-2">–õ–æ–≥ –¥–µ–π—Å—Ç–≤–∏–π</div>
<div class="bg-gray-900/60 border border-white/10 rounded-lg p-3 max-h-[680px] overflow-auto space-y-1 text-sm" id="action-log">
<!-- rows -->
</div>
</div>
</aside>
</div>
</div></section>
<script>
    // ====== Game Demo code with trails + action log (same behavior) ======
    let GRID_SIZE = 10;
    let robot1 = { x: 1, y: 1, hp: 100, shield: 0 };
    let robot2 = { x: 8, y: 8, hp: 100, shield: 0 };
    let traps = [];
    let shots = [];
    let turnNumber = 1;

// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–∫–æ—Ä–æ—Å—Ç–∏ —Å–∏–º—É–ª—è—Ü–∏–∏ (—Å–µ–∫—É–Ω–¥ –Ω–∞ —Ö–æ–¥)
let moveDelaySec = 1.0;
let gameTimer = null;

function scheduleNextTick(){
  if (gameTimer) clearTimeout(gameTimer);
  gameTimer = setTimeout(() => {
    if (robot1.hp > 0 && robot2.hp > 0) {
      makeMove();
      scheduleNextTick();
    } else {
      const winnerId = (robot1.hp <= 0 && robot2.hp > 0) ? 2 : 1;
      showWinner(winnerId);
      setTimeout(() => { resetGame(); scheduleNextTick(); }, 3000);
    }
  }, moveDelaySec * 1000);
}
// --- Winner banner (2s) ---
function showWinner(winnerId){
  const overlay = document.getElementById('win-overlay');
  const textEl = document.getElementById('win-text');
  const metaEl = document.getElementById('win-meta');
  if (!overlay || !textEl) return;
  const isR1 = winnerId === 1;
  textEl.textContent = isR1 ? '–ü–æ–±–µ–¥–∏–ª —Ä–æ–±–æ—Ç R1 üèÜ' : '–ü–æ–±–µ–¥–∏–ª —Ä–æ–±–æ—Ç R2 üèÜ';
  textEl.classList.remove('text-blue-300','text-red-300');
  textEl.classList.add(isR1 ? 'text-blue-300' : 'text-red-300');
  overlay.classList.remove('hidden','fade-out');
  if (metaEl) { const turn = turnNumber; const r1hp = robot1.hp; const r2hp = robot2.hp; metaEl.textContent = `–•–æ–¥ ${turn} ‚Ä¢ R1: ${r1hp} HP ‚Ä¢ R2: ${r2hp} HP`; }
  overlay.classList.add('fade-in');
  setTimeout(() => {
    overlay.classList.remove('fade-in');
    overlay.classList.add('fade-out');
    setTimeout(() => { overlay.classList.add('hidden'); }, 200);
  }, 2000);
}


function setupSpeedControls(){
  const slider = document.getElementById('speed-slider');
  const label = document.getElementById('speed-label');
  if (!slider || !label) return;
  const fmt = (v)=> (Math.round(v*100)/100).toString().replace(/\.00$/, '');
  label.textContent = fmt(slider.value) + ' —Å/—Ö–æ–¥';
  slider.addEventListener('input', (e)=>{
    moveDelaySec = parseFloat(e.target.value);
    label.textContent = fmt(moveDelaySec) + ' —Å/—Ö–æ–¥';
    scheduleNextTick();
  });
}

    let currentRobot = 1;

// --- Scan overlay (Chebyshev) ---
const SCAN_RADIUS = 2;
let scanOverlay = []; // items: {x,y,expiresAt,by}
const SCAN_PROB = 0.30;
// ===== Scan visuals (tunable) =====
const SCAN_BLUE_RGB = '59,130,246';   // R1 outline/fill color (r,g,b)
const SCAN_RED_RGB  = '239,68,68';    // R2 outline/fill color (r,g,b)
const SCAN_OUTLINE_WIDTH = 2;         // px
const SCAN_FILL_ALPHA    = 0.12;      // 0..1 transparency of fill
const SCAN_GLOW_ALPHA    = 0.55;      // 0..1 transparency of glow
// Fog of War
let FOG_ENABLED = false;
const FOG_RADIUS = 3;

function isCellVisible(x, y){
  if (!FOG_ENABLED) return true;
  const viewer = (currentRobot === 1) ? robot1 : robot2;
  const dist = Math.max(Math.abs(x - viewer.x), Math.abs(y - viewer.y));
  if (dist <= FOG_RADIUS) return true;
  for (let k = scanOverlay.length - 1; k >= 0; k--) {
    const s = scanOverlay[k];
    if (s.by === currentRobot && Date.now() < s.expiresAt && s.x === x && s.y === y) return true;
  }
  return false;
}

function applyGridStyles(){
  const grid = document.getElementById('game-demo');
  if (!grid) return;
  grid.style.gridTemplateColumns = `repeat(${GRID_SIZE}, minmax(0, 1fr))`;
  grid.style.gridTemplateRows = `repeat(${GRID_SIZE}, minmax(0, 1fr))`;
}

function setGridSize(n){
  n = parseInt(n, 10);
  if (isNaN(n)) n = 10;
  n = Math.max(4, Math.min(30, n));
  GRID_SIZE = n;
  // Reset game state safely
  traps = [];
  shots = [];
  trail1.length = 0;
  trail2.length = 0;
  scanOverlay.length = 0;
  hitUntil[1] = 0; hitUntil[2] = 0;
  lastAction[1] = null; lastAction[2] = null;
  actionLog.length = 0; renderLog();
  energy[1] = 6; energy[2] = 6;
  turnNumber = 1; currentRobot = 1;
  spawnRobotsRandomly();
energy = { 1: TURN_ENERGY, 2: TURN_ENERGY };
turnFresh = { 1: true, 2: true };
try{ updateEnergyUI(); }catch(e){}
  pushTrail(1, robot1.x, robot1.y);
  pushTrail(2, robot2.x, robot2.y);
  applyGridStyles();
  initGrid();
  render();
}

// ==================================

let shootFxUntil = { 1: 0, 2: 0 };

let currentTurnActions = 0;
// --- Energy system ---
const ENERGY = { move: 1, shoot: 3, scan: 2, shield: 4, trap: 3 };
const ENERGY_REGEN = 3;
let energy = { 1: 6, 2: 6 };
function spendEnergy(id, cost){ if (energy[id] >= cost){ energy[id]-=cost; return true;} return false; }


// --- Random spawn helpers ---
function randInt(n){ return Math.floor(Math.random() * n); }
function chebyshev(a,b){ return Math.max(Math.abs(a.x-b.x), Math.abs(a.y-b.y)); }
/**
 * Puts robots on random distinct cells with minimal Chebyshev separation.
 * Adjust minSep if you want them farther/closer.
 */
function spawnRobotsRandomly(minSep = 4){
  // Ensure objects exist
  if (!robot1) robot1 = { x: 0, y: 0, hp: 100, shield: 0 };

// --- Turn-based energy budget ---
TURN_ENERGY = 20;
turnFresh = { 1: true, 2: true };
  if (!robot2) robot2 = { x: 0, y: 0, hp: 100, shield: 0 };
  let p1 = { x: randInt(GRID_SIZE), y: randInt(GRID_SIZE) };
  let p2 = { x: randInt(GRID_SIZE), y: randInt(GRID_SIZE) };
  let guard = 0;
  while ((p2.x === p1.x && p2.y === p1.y) || chebyshev(p1, p2) < minSep){
    p2 = { x: randInt(GRID_SIZE), y: randInt(GRID_SIZE) };
    if (++guard > 1000) break; // fallback if grid too small
  }
  robot1.x = p1.x; robot1.y = p1.y;
  robot2.x = p2.x; robot2.y = p2.y;
}


    const trail1 = []; const trail2 = []; const MAX_TRAIL = 30;
    let lastAction = { 1: null, 2: null };
    // randomized scanning; counter removed
    // –î–æ –∫–∞–∫–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é –ø–æ–ø–∞–¥–∞–Ω–∏—è
    let hitUntil = { 1: 0, 2: 0 };
    const actionLog = [];

    const to1 = n => n + 1;
    const coord = (x, y) => `(${to1(x)}, ${to1(y)})`;

    function setLastAction(id, text){ lastAction[id] = { text, expireAt: Date.now() + 1800 }; }
    


function addLog(id, text, turn){
  actionLog.push({ id, text, turn });
  if (actionLog.length > 200) actionLog.shift();
  renderLog();
}

function renderLog(){
      const log = document.getElementById('action-log'); if(!log) return;
      const items = actionLog.slice(-50).reverse(); // newest first
      let lastTurn = null;
      const parts = [];
      for (const e of items) {
        if (lastTurn !== null && e.turn !== lastTurn) {
          parts.push('<div class="border-t border-white/20 my-2"></div>');
        }
        lastTurn = e.turn;
        const dot = e.id === 1 ? 'bg-blue-500' : 'bg-red-500';
        parts.push(`<div class="flex items-start gap-2">
            <span class="mt-1 inline-block w-2 h-2 rounded-full ${dot}"></span>
            <span class="text-gray-300">${e.text}</span>
            <span class="ml-auto text-xs text-gray-500">—Ö–æ–¥ ${e.turn}</span>
          </div>`);
      }
      log.innerHTML = parts.join('') || '<div class="text-gray-500 text-sm">–õ–æ–≥ –ø—É—Å—Ç</div>';
    }
    function pushTrail(id,x,y){ const arr = id===1?trail1:trail2; arr.push({x,y}); if(arr.length>MAX_TRAIL) arr.shift(); }

    function initGrid(){ applyGridStyles(); const grid = document.getElementById('game-demo'); grid.innerHTML='';
      for(let y=0;y<GRID_SIZE;y++){ for(let x=0;x<GRID_SIZE;x++){ const cell=document.createElement('div'); cell.className = 'cell bg-gray-800 rounded transition-all duration-300'; cell.dataset.x=x; cell.dataset.y=y; grid.appendChild(cell);}}
      pushTrail(1, robot1.x, robot1.y); pushTrail(2, robot2.x, robot2.y);
    }

    function appendShadow(existing, extra){ if(!existing||existing==='none') return extra; return existing+', '+extra; }

    function updateEnergyUI(){
  const e1 = document.getElementById('energy-r1');
  const e2 = document.getElementById('energy-r2');
  const hp1 = document.getElementById('hp-r1');
  const hp2 = document.getElementById('hp-r2');
  const sh1 = document.getElementById('shield-r1');
  const sh2 = document.getElementById('shield-r2');

  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∞–ª—å–Ω—É—é —ç–Ω–µ—Ä–≥–∏—é —Ç–æ–ª—å–∫–æ –¥–ª—è –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ä–æ–±–æ—Ç–∞,
  // –∞ –¥–ª—è –æ–∂–∏–¥–∞—é—â–µ–≥–æ ‚Äî –≤—Å–µ–≥–¥–∞ –±—é–¥–∂–µ—Ç —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ö–æ–¥–∞ (20)
  const e1Val = (typeof currentRobot !== 'undefined' && currentRobot === 1) ? energy[1] : TURN_ENERGY;
  const e2Val = (typeof currentRobot !== 'undefined' && currentRobot === 2) ? energy[2] : TURN_ENERGY;

  if (e1) e1.textContent = String(e1Val);
  if (e2) e2.textContent = String(e2Val);
  if (hp1) hp1.textContent = String(robot1.hp);
  if (hp2) hp2.textContent = String(robot2.hp);
  if (sh1) sh1.textContent = String(robot1.shield || 0);
  if (sh2) sh2.textContent = String(robot2.shield || 0);
}

function render(){
      const cells = document.querySelectorAll('#game-demo > div');
      cells.forEach(cell => {
        
  // Fog of War: hide invisible cells completely (Option 1)
    if (typeof isCellVisible === 'function') {
      const cx = +cell.dataset.x;
      const cy = +cell.dataset.y;
      const visible = isCellVisible(cx, cy);
      if (!visible) {
        cell.className = 'cell bg-gray-900 rounded transition-all duration-300 opacity-40';
        cell.style.filter = 'grayscale(0.8) brightness(0.6)';
        cell.textContent = '';
        cell.style.outline = '';
        cell.style.boxShadow = '';
        return;
}
    }
    const x = +cell.dataset.x, y = +cell.dataset.y;
        cell.className = 'cell bg-gray-800 rounded transition-all duration-300'; cell.innerHTML=''; cell.style.boxShadow='none'; cell.style.backgroundColor=''; cell.style.backgroundImage='none'; cell.style.outline='none'; cell.style.outlineOffset='0px'; cell.style.backgroundColor=''; cell.style.backgroundImage='none'; cell.style.outline='none'; cell.style.outlineOffset='0px'; cell.style.filter=''; cell.style.outline='none'; cell.style.outlineOffset='0px'; cell.style.outline='none'; cell.style.outlineOffset='0px'; cell.style.backgroundImage='none'; cell.style.backgroundBlendMode=''; cell.style.backgroundColor=''; cell.style.outline='none';
        let shadow='';
        const i1 = trail1.findIndex(p=>p.x===x && p.y===y);
        if(i1!==-1){ const t=(i1+1)/trail1.length, a=0.30*t+0.05; shadow=appendShadow(shadow,`inset 0 0 14px rgba(59,130,246,${a}), 0 0 18px rgba(59,130,246,${a*.8})`); }
        const i2 = trail2.findIndex(p=>p.x===x && p.y===y);
        if(i2!==-1){ const t=(i2+1)/trail2.length, a=0.30*t+0.05; shadow=appendShadow(shadow,`inset 0 0 14px rgba(239,68,68,${a}), 0 0 18px rgba(239,68,68,${a*.8})`); }
        if(shadow) cell.style.boxShadow=shadow;

        const isScanned = scanOverlay.some(s => s.x===x && s.y===y && Date.now() < s.expiresAt);
if (isScanned) {
  cell.style.backgroundColor = 'rgba(134,239,172,0.28)';
  cell.style.outline = '2px solid rgba(74,222,128,0.95)';
  cell.style.outlineOffset = '-2px';
  shadow = appendShadow(shadow, '0 0 10px rgba(134,239,172,0.35)');
}
if (shadow) cell.style.boxShadow = shadow;
let scanEntry = null;
for (let k = scanOverlay.length - 1; k >= 0; k--) {
  const s = scanOverlay[k];
  if (s.x===x && s.y===y && Date.now() < s.expiresAt) { scanEntry = s; break; }
}
if (scanEntry) {
  const isBlue = scanEntry.by === 1;
  const rgb = isBlue ? SCAN_BLUE_RGB : SCAN_RED_RGB;
  cell.style.backgroundColor = `rgba(${rgb}, ${SCAN_FILL_ALPHA})`;
  cell.style.outline = `${SCAN_OUTLINE_WIDTH}px solid rgba(${rgb}, 0.98)`;
  cell.style.outlineOffset = '-2px';
  shadow = appendShadow(shadow, `0 0 10px rgba(${rgb}, ${SCAN_GLOW_ALPHA})`);
}
if (shadow) cell.style.boxShadow = shadow;
const shot = shots.find(s=>s.x===x && s.y===y); if(shot) cell.className='bg-yellow-500 rounded transition-all duration-300';
        const trap = traps.find(t=>t.x===x && t.y===y); if(trap){ cell.className='bg-orange-500 rounded opacity-50 transition-all duration-300'; cell.innerHTML='<div class="w-full h-full flex items-center justify-center text-xs">üí£</div>'; }

        if(robot1.x===x && robot1.y===y){
          const pill=(lastAction[1] && Date.now()<lastAction[1].expireAt)?`<div class="pill absolute -top-6 left-1/2 -translate-x-1/2 text-[10px] whitespace-nowrap px-2 py-1 rounded-full bg-black/60 border border-white/10 ${lastAction[1]?.kind==='damage'?'text-red-400':''}
// FX for shooter R1
if (robot1.x===x && robot1.y===y && typeof shootFxUntil !== 'undefined' && Date.now() < (shootFxUntil[1]||0)) {
  cell.className += ' shooter-saturate shooter-ring-blue';
}">R1: ${lastAction[1].text}</div>`:'';
          const isHit = Date.now() < hitUntil[1];
          cell.className='bg-blue-600 rounded transition-all duration-300 pulse-glow';
          cell.innerHTML=`<div class="w-full h-full flex items-center justify-center text-white font-bold text-xs relative ${isHit ? 'hit-pulse shake' : ''}">
            ${pill}
            R1
            ${robot1.shield>0?'<span class="absolute -top-1 -right-1 text-cyan-400">üõ°Ô∏è</span>':''}
          </div>`;
        }
        if(robot2.x===x && robot2.y===y){
          const pill=(lastAction[2] && Date.now()<lastAction[2].expireAt)?`<div class="pill absolute -top-6 left-1/2 -translate-x-1/2 text-[10px] whitespace-nowrap px-2 py-1 rounded-full bg-black/60 border border-white/10 ${lastAction[2]?.kind==='damage'?'text-red-400':''}
// FX for shooter R2
if (robot2.x===x && robot2.y===y && typeof shootFxUntil !== 'undefined' && Date.now() < (shootFxUntil[2]||0)) {
  cell.className += ' shooter-saturate shooter-ring-red';
}">R2: ${lastAction[2].text}</div>`:'';
          const isHit = Date.now() < hitUntil[2];
          cell.className='bg-red-600 rounded transition-all duration-300 pulse-glow';
          cell.innerHTML=`<div class="w-full h-full flex items-center justify-center text-white font-bold text-xs relative ${isHit ? 'hit-pulse shake' : ''}">
            ${pill}
            R2
            ${robot2.shield>0?'<span class="absolute -top-1 -right-1 text-cyan-400">üõ°Ô∏è</span>':''}
          </div>`;
        }

        if(currentRobot===1 && robot1.x===x && robot1.y===y){ cell.style.boxShadow=appendShadow(cell.style.boxShadow,'0 0 20px rgba(59,130,246,0.8)'); }
        else if(currentRobot===2 && robot2.x===x && robot2.y===y){ cell.style.boxShadow=appendShadow(cell.style.boxShadow,'0 0 20px rgba(239,68,68,0.8)'); }
      });
      const r1=document.getElementById('robot1-hp'), r2=document.getElementById('robot2-hp'), tn=document.getElementById('turn-number');
      if(r1) r1.textContent=robot1.hp; if(r2) r2.textContent=robot2.hp; if(tn) tn.textContent=turnNumber; const e1=document.getElementById('robot1-energy'); if(e1) e1.textContent=energy[1]; const e2=document.getElementById('robot2-energy'); if(e2) e2.textContent=energy[2];
    }

    function dirName(dx,dy){ if(dx===1&&dy===0)return'–≤–ø—Ä–∞–≤–æ'; if(dx===-1&&dy===0)return'–≤–ª–µ–≤–æ'; if(dx===0&&dy===-1)return'–≤–≤–µ—Ä—Ö'; if(dx===0&&dy===1)return'–≤–Ω–∏–∑'; if(dx===1&&dy===1)return'–≤–ø—Ä–∞–≤–æ-–≤–Ω–∏–∑'; if(dx===1&&dy===-1)return'–≤–ø—Ä–∞–≤–æ-–≤–≤–µ—Ä—Ö'; if(dx===-1&&dy===1)return'–≤–ª–µ–≤–æ-–≤–Ω–∏–∑'; if(dx===-1&&dy===-1)return'–≤–ª–µ–≤–æ-–≤–≤–µ—Ä—Ö'; return'—Å—Ç–æ–∏—Ç –Ω–∞ –º–µ—Å—Ç–µ'; }
    // Chebyshev distance
    function cheb(a,b){ return Math.max(Math.abs(a.x-b.x), Math.abs(a.y-b.y)); }

    // Apply scan: mark cells within radius for 1s and report detections
    function scanArea(id, me, radius = SCAN_RADIUS){
      const now = Date.now();
      scanOverlay = scanOverlay.filter(s => now < s.expiresAt);
      for(let y=0;y<GRID_SIZE;y++){
        for(let x=0;x<GRID_SIZE;x++){
          if (Math.max(Math.abs(x - me.x), Math.abs(y - me.y)) <= radius){
            scanOverlay.push({ x, y, expiresAt: now + 1500, by: id });
          }
        }
      }
      const enemy = (id===1) ? robot2 : robot1;
      
  let noEnergy = false;
const energyBefore = energy[id];
const sawEnemy = Math.max(Math.abs(enemy.x - me.x), Math.abs(enemy.y - me.y)) <= radius;
      const trapsCount = traps.filter(t => Math.max(Math.abs(t.x - me.x), Math.abs(t.y - me.y)) <= radius).length;
      return `—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ r=${radius}: ${sawEnemy?`–≤—Ä–∞–≥ –æ–±–Ω–∞—Ä—É–∂–µ–Ω`:`–≤—Ä–∞–≥–∞ –Ω–µ—Ç`}, –ª–æ–≤—É—à–µ–∫: ${trapsCount}`;
    }


    





function makeMove(){
  const turnAtStart = turnNumber;

  // –°–ø—Ä—è—Ç–∞—Ç—å –ø–ª–∞—à–∫—É —É –æ–∂–∏–¥–∞—é—â–µ–≥–æ —Ä–æ–±–æ—Ç–∞ (–∫—Ä–æ–º–µ –∞–∫—Ç–∏–≤–Ω–æ–π –ø–ª–∞—à–∫–∏ —É—Ä–æ–Ω–∞)
  const waitingId = currentRobot === 1 ? 2 : 1;
  if (!(lastAction[waitingId] && lastAction[waitingId].kind === 'damage' && Date.now() < lastAction[waitingId].expireAt)) {
    lastAction[waitingId] = null;
  }

  const id = currentRobot;
  const me = (id === 1) ? robot1 : robot2;
  const enemy = (id === 1) ? robot2 : robot1;

  
  let noEnergy = false;
const energyBefore = energy[id];
// –≠–Ω–µ—Ä–≥–∏—è —Ö–æ–¥–∞: 20 –≤ –Ω–∞—á–∞–ª–µ –Ω–æ–≤–æ–≥–æ —Ö–æ–¥–∞
  if (turnFresh[id]) { energy[id] = TURN_ENERGY; turnFresh[id] = false; }
  currentTurnActions = 0;
const dx = enemy.x - me.x;
  const dy = enemy.y - me.y;
  const distance = Math.max(Math.abs(dx), Math.abs(dy));

  let note = '';

  // –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
  if (Math.random() < SCAN_PROB && spendEnergy(id, ENERGY.scan)) {
    note = scanArea(id, me, SCAN_RADIUS);
  } else {
    const rnd = Math.random();
    if (rnd < 0.35 && distance <= 5 && spendEnergy(id, ENERGY.shoot))      { note = shoot(me, enemy); }
    else if (rnd < 0.55 && spendEnergy(id, ENERGY.move))                    { note = moveTowards(id, me, enemy); }
    else if (rnd < 0.75 && spendEnergy(id, ENERGY.trap))                    { note = placeTrap(me); }
    else if (rnd < 0.90 && me.shield === 0 && me.hp < 60 && spendEnergy(id, ENERGY.shield)) { me.shield = 2; note = '–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª —â–∏—Ç'; }
    else if (spendEnergy(id, ENERGY.move))                                  { note = randomMove(id, me); }
    else { note = '–ø—Ä–æ–ø—É—Å—Ç–∏–ª —Ö–æ–¥ (–Ω–µ—Ç —ç–Ω–µ—Ä–≥–∏–∏)'; noEnergy = true; }
  }

  if (me.shield > 0) me.shield--;  
  if (!noEnergy && energy[id] < energyBefore) { currentTurnActions++; }
if (noEnergy) {
    currentRobot = (currentRobot === 1) ? 2 : 1;
    turnFresh[currentRobot] = true;
    if (currentRobot === 1) turnNumber++;
  }
  if (noEnergy) { currentTurnActions = 0; }

if (note) {
    setLastAction(id, note);
    if (typeof addLog === 'function') addLog(id, `${note} [—ç–Ω–µ—Ä–≥–∏—è: ${energy[id]}]`, turnAtStart);
  }
  render();

  try{ updateEnergyUI(); }catch(e){}
}

function shoot(shooter, target){
  shots = [];
  // Build path from shooter towards target (8 directions)
  const dx = Math.sign(target.x - shooter.x), dy = Math.sign(target.y - shooter.y);
  let x = shooter.x + dx, y = shooter.y + dy;
  const path = [];
  let willHit = false, brokeShield = false;
  const preShield = target.shield;
  while (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
    path.push({x,y});
    if (x === target.x && y === target.y) { willHit = true; break; }
    x += dx; y += dy;
  }
  // Shooter FX window (saturate + ring)
  const shooterId = (shooter === robot1) ? 1 : 2;
  shootFxUntil[shooterId] = Date.now() + 800;

  // Animate beam along path
  let i = 0;
  const step = () => {
    shots = path.slice(0, i+1);
    render();
    i++;
    if (i < path.length) {
      setTimeout(step, 45);
    } else {
      // Apply hit effects at the end
      if (willHit) {
        if (preShield > 0) { target.shield = 0; brokeShield = true; }
        else { target.hp = Math.max(0, target.hp - 20); }
        // Target hit pulse + damage pill
        const targetId = (shooter === robot1) ? 2 : 1;
        hitUntil[targetId] = Date.now() + 1500;
        const dmgText = brokeShield ? '—â–∏—Ç —Ä–∞–∑—Ä—É—à–µ–Ω' : '‚àí20 HP';
        lastAction[targetId] = { text: dmgText, expireAt: Date.now() + 1500, kind: 'damage' };
      }
      setTimeout(() => { shots = []; render(); }, 220);
    }
  };
  step();

  const dirText = dirName(Math.sign(dx), Math.sign(dy));
  if (preShield > 0 && willHit) return `–≤—ã—Å—Ç—Ä–µ–ª ${dirText} ‚Äî —â–∏—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ —Ä–∞–∑—Ä—É—à–µ–Ω`;
  if (willHit) return `–≤—ã—Å—Ç—Ä–µ–ª ${dirText} ‚Äî –ø–æ–ø–∞–¥–∞–Ω–∏–µ (-20 HP)`;
  return `–≤—ã—Å—Ç—Ä–µ–ª ${dirText} ‚Äî –ø—Ä–æ–º–∞—Ö`;
}

    function moveTowards(id, me, target){
  const diffX = Math.abs(target.x - me.x);
  const diffY = Math.abs(target.y - me.y);
  const stepX = Math.sign(target.x - me.x);
  const stepY = Math.sign(target.y - me.y);
  const useX = diffX >= diffY;
  return moveRobot(id, me, useX ? stepX : 0, useX ? 0 : stepY, '—à–∞–≥');
}
    function randomMove(id,me){ const dirs=[{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}]; const d=dirs[Math.floor(Math.random()*dirs.length)]; return moveRobot(id,me,d.dx,d.dy,'—Å–ª—É—á–∞–π–Ω—ã–π —à–∞–≥'); }
    function moveRobot(id,me,dx,dy,label){
      const from={x:me.x,y:me.y}; const newX=me.x+dx, newY=me.y+dy; let moved=false, trapHit=false;
      if(newX>=0&&newX<GRID_SIZE&&newY>=0&&newY<GRID_SIZE){ const other=me===robot1?robot2:robot1; if(newX!==other.x||newY!==other.y){ me.x=newX; me.y=newY; moved=true; pushTrail(id,me.x,me.y); const ti=traps.findIndex(t=>t.x===newX&&t.y===newY&&t.owner!==me); if(ti!==-1){ me.hp=Math.max(0,me.hp-15); traps.splice(ti,1); trapHit=true; } } }
      if(moved){ const dirT=dirName(Math.sign(me.x-from.x),Math.sign(me.y-from.y)); return `${label} ${dirT} ${coord(from.x,from.y)} ‚Üí ${coord(me.x,me.y)}${trapHit?' ‚Äî –Ω–∞—Å—Ç—É–ø–∏–ª –Ω–∞ –ª–æ–≤—É—à–∫—É (-15 HP)':''}`; }
      return `${label} ‚Äî –±–µ–∑ –¥–≤–∏–∂–µ–Ω–∏—è`;
    }
    function placeTrap(me){ if(traps.length<5 && !traps.find(t=>t.x===me.x&&t.y===me.y)){ traps.push({x:me.x,y:me.y,owner:me}); return `—É—Å—Ç–∞–Ω–æ–≤–∏–ª –ª–æ–≤—É—à–∫—É –≤ ${coord(me.x,me.y)}`; } return '–ø—ã—Ç–∞–ª—Å—è –ø–æ—Å—Ç–∞–≤–∏—Ç—å –ª–æ–≤—É—à–∫—É, –Ω–æ –∑–¥–µ—Å—å —É–∂–µ –µ—Å—Ç—å'; }

    

function resetGame(){
  turnFresh = { 1: true, 2: true };
  energy = { 1: TURN_ENERGY, 2: TURN_ENERGY };
  // Reset state
  robot1 = { x: 0, y: 0, hp: 100, shield: 0 };
  robot2 = { x: 0, y: 0, hp: 100, shield: 0 };
  traps = [];
  shots = [];
  turnNumber = 1;
  currentRobot = 1;

  // Clear visuals/meta
  trail1.length = 0;
  trail2.length = 0;
  lastAction = { 1: null, 2: null };
  actionLog.length = 0;
  renderLog();
  if (typeof hitUntil !== 'undefined') { hitUntil = { 1: 0, 2: 0 }; }

  // Random spawn and seed trails
  spawnRobotsRandomly();
  pushTrail(1, robot1.x, robot1.y);
  pushTrail(2, robot2.x, robot2.y);

  render();

}

(function(){
  const r = document.getElementById('grid-size');
  const s = document.getElementById('grid-size-val');
  if (r && s) {
    r.value = GRID_SIZE;
    s.textContent = `${GRID_SIZE}√ó${GRID_SIZE}`;
    r.addEventListener('input', e => { s.textContent = `${e.target.value}√ó${e.target.value}`; });
    r.addEventListener('change', e => { setGridSize(e.target.value); });
  }
  applyGridStyles();
})();


(function(){
  const fog = document.getElementById('fog-toggle');
  if (fog) {
    fog.checked = FOG_ENABLED;
    fog.addEventListener('change', () => { FOG_ENABLED = fog.checked; render(); });
  }
})();
spawnRobotsRandomly();
pushTrail(1, robot1.x, robot1.y);
pushTrail(2, robot2.x, robot2.y);
initGrid(); render(); renderLog();
setupSpeedControls();
scheduleNextTick();
</script>
</body>
</html>
